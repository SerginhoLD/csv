<?php
/**
 * CSV Parser
 * 
 * @author Sergey Zubrilin https://github.com/SerginhoLD
 * 
 * @link https://en.wikipedia.org/wiki/Comma-separated_values
 * @link https://www.rfc-editor.org/rfc/rfc4180.txt RFC 4180
 * @link http://tradeincome.ru/useful-content/RFC%204180%20rus.pdf RFC 4180 –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ
 * 
 * @license MIT
 */

namespace SerginhoLD\CSV;

use SerginhoLD\CSV\Exception\FileNotFoundException;
use SerginhoLD\CSV\Exception\WrongFileMimeTypeException;

/**
 * Class Parser
 * @package SerginhoLD\CSV
 */
class Parser extends \ArrayObject
{
    /**
     * @var string –†–∞–∑—Ä—ã–≤ —Å—Ç—Ä–æ–∫–∏
     */
    const CRLF = "\r\n";
    
    /**
     * @var string –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å (–¢–æ–ª—å–∫–æ –æ–¥–∏–Ω —Å–∏–º–≤–æ–ª)
     */
    protected $delimiter = ',';
    
    /**
     * @var string –û–≥—Ä–∞–Ω–∏—á–∏—Ç–µ–ª—å –ø–æ–ª–µ–π (–¢–æ–ª—å–∫–æ –æ–¥–∏–Ω —Å–∏–º–≤–æ–ª)
     */
    protected $enclosure = '"';
    
    /**
     * @var array Mime-—Ç–∏–ø—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ñ–∞–π–ª–æ–≤
     */
    protected $mimeTypes = [
        'text/plain',
        'text/csv',
        'text/tsv',
        'application/vnd.ms-excel'
    ];
    
    /**
     * @var string
     */
    protected $inputEncoding = 'UTF-8';
    
    /**
     * @var string
     */
    protected $outputEncoding = 'UTF-8';
    
    /**
     * @var bool –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –ø–æ–ª–µ–π
     */
    protected $withHeaders = false;
    
    /**
     * @var array –ó–∞–≥–æ–ª–æ–≤–∫–∏ –ø–æ–ª–µ–π
     */
    protected $headers = [];
    
    /**
     * @var \finfo
     * @see http://php.net/manual/ru/class.finfo.php
     */
    protected static $finfo;
    
    /**
     * {@inheritdoc}
     */
    public function __construct($input = [], $flags = 0, $iterator_class = "ArrayIterator")
    {
        if (!(self::$finfo instanceof \finfo))
        {
            self::$finfo = new \finfo;
        }
        
        parent::__construct($input, $flags, $iterator_class);
    }
    
    /**
     * –†–∞–∑–±–æ—Ä CSV
     * 
     * @param string $data
     * 
     * @return $this
     */
    public function parse($data)
    {
        if ($this->inputEncoding !== $this->outputEncoding)
        {
            $data = mb_convert_encoding($data, $this->outputEncoding, $this->inputEncoding);
        }
        
        $result = str_replace(self::CRLF, "\n", $data); // Linux or Windows? üòï
        $result = explode("\n", $result);
        
        $result = array_filter($result, function($row) {
            return $row !== '';
        });
        
        $issetNextRow = true;
        $index = key($result);
        $maxRowSize = 0;
        
        while ($issetNextRow)
        {
            next($result);
            $nextIndex = key($result);
            $issetNextRow = isset($result[$nextIndex]);
            
            $row = &$result[$index];
            $countEnclosure = mb_substr_count($row, $this->enclosure, $this->outputEncoding);
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª-–≤–æ —Å–∏–º–≤–æ–ª–æ–≤ –æ–≥—Ä–∞–Ω–∏—á–∏—Ç–µ–ª—è –ø–æ–ª–µ–π –≤ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–æ–∫–µ.
            // –ï—Å–ª–∏ –∏—Ö –Ω–µ—á–µ—Ç–Ω–æ–µ –∫–æ–ª-–≤–æ, –∑–Ω–∞—á–∏—Ç –≤ –æ–¥–Ω–æ–º –∏–∑ –ø–æ–ª–µ–π —Å—Ç—Ä–æ–∫–∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è —Å–∏–º–≤–æ–ª —Ä–∞–∑—Ä—ã–≤–∞ —Å—Ç—Ä–æ–∫–∏,
            // –æ–±—ä–µ–¥–∏–Ω—è–µ–º —Ç–µ–∫—É—â—É—é —Å—Ç—Ä–æ–∫—É —Å–æ —Å–ª–µ–¥—É—é—â–µ–π –∏ –ø—Ä–æ–≤–µ—Ä—è–º –∑–∞–Ω–æ–≤–æ.
            if ($countEnclosure % 2 !== 0 && $issetNextRow)
            {
                $row .= self::CRLF . $result[$nextIndex];
                unset($result[$nextIndex]);
    
                prev($result);
            }
            else
            {
                $row = $this->parseRow($row, $this->delimiter, $this->enclosure);
                $index = $nextIndex;
                
                $rowSize = count($row);
                $maxRowSize = ($rowSize > $maxRowSize) ? $rowSize : $maxRowSize;
            }
        }
        
        // –ö–∞–∂–¥–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–æ–ª–∂–Ω–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª–µ–π –ø–æ –≤—Å–µ–º—É —Ñ–∞–π–ª—É
        $result = array_map(function($row) use ($maxRowSize) {
            return array_pad($row, $maxRowSize, null);
        }, array_values($result));
        
        if ($this->withHeaders)
        {
            $this->headers = $headers = $result[0];
            unset($result[0]);
            
            $result = array_map(function($row) use ($headers) {
                return array_combine($headers, $row);
            }, array_values($result));
        }
        
        $this->exchangeArray($result);
        
        return $this;
    }
    
    /**
     * –†–∞–∑–±–æ—Ä –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
     * 
     * Magic! ‚ú®
     * –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä `$escape` –≤ `str_getcsv` —Ä–∞–≤–µ–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä—É `$enclosure`.
     * –ö–∞–∫-—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–∏—á–µ–≥–æ –Ω–µ —ç–∫—Ä–∞–Ω–∏—Ä—É—è, –∏–±–æ RFC 4180 (–ü–æ–ª—è —Å–æ —Å–ø–µ—Ü. —Å–∏–º–≤–æ–ª–∞–º–∏ –∑–∞–∫–ª—é—á–∞—é—Ç—Å—è –≤ –∫–∞–≤—ã—á–∫–∏).
     * 
     * @param string $str
     * @param string $delimiter
     * @param string $enclosure
     * 
     * @return array
     */
    public function parseRow($str, $delimiter, $enclosure)
    {
        return str_getcsv($str, $delimiter, $enclosure, $enclosure);
    }
    
    /**
     * –†–∞–∑–±–æ—Ä CSV-—Ñ–∞–π–ª–∞
     *
     * @param string $path
     *
     * @throws FileNotFoundException
     * @throws WrongFileMimeTypeException
     *
     * @return $this
     */
    public function parseFile($path)
    {
        if (!in_array($this->getFileMimeType($path), $this->mimeTypes, true))
        {
            throw new WrongFileMimeTypeException($path);
        }
        
        $data = null;
        $file = fopen($path, 'r');
        
        while (($buffer = fgets($file)) !== false)
        {
            $data .= $buffer;
        }
        
        fclose($file);
        
        return $this->parse($data);
    }
    
    /**
     * –ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –∑–∞–¥–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
     *
     * @param mixed $index
     * @param array $value One-dimensional array
     *
     * @throws \InvalidArgumentException
     */
    public function offsetSet($index, $value)
    {
        if (!is_array($value) || count(array_filter($value, 'is_array')))
        {
            throw new \InvalidArgumentException('Argument `$value` is not a one-dimensional array');
        }
        
        $newRowSize = count($value);
        $csvFirstRowKey = key($this->getArrayCopy());
        $csvRowSize = ($csvFirstRowKey !== null) ? count($this[$csvFirstRowKey]) : 0;
        
        if ($csvRowSize)
        {
            if ($csvRowSize > $newRowSize)
            {
                $value = array_pad($value, $csvRowSize, null);
            }
            else if ($csvRowSize < $newRowSize)
            {
                // or Exception?
                $this->exchangeArray(array_map(function($row) use ($newRowSize) {
                    return array_pad($row, $newRowSize, null);
                }, $this->getArrayCopy()));
            }
        }
        
        if ($this->inputEncoding !== $this->outputEncoding)
        {
            $value = array_map(function($cell) {
                return mb_convert_encoding($cell, $this->outputEncoding, $this->inputEncoding);
            }, $value);
        }
        
        parent::offsetSet($index, $value);
    }
    
    /**
     * –î–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É
     *
     * @param array $value One-dimensional array
     */
    public function append($value)
    {
        $this->offsetSet(null, $value);
    }
    
    /**
     * –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –º–∞—Å—Å–∏–≤ –¥–∞–Ω–Ω—ã—Ö –≤ CSV-—Ñ–æ—Ä–º–∞—Ç
     * 
     * @return string
     */
    public function __toString()
    {
        return implode(self::CRLF, array_map(function($row) {
            
            return implode($this->delimiter, array_map(function($cell) {
                
                $countEnclosure = mb_substr_count($cell, $this->enclosure, $this->outputEncoding);
                $countDelimiter = mb_substr_count($cell, $this->delimiter, $this->outputEncoding);
                $countCR = mb_substr_count($cell, "\r", $this->outputEncoding);
                $countLF = mb_substr_count($cell, "\n", $this->outputEncoding);
    
                if ($countEnclosure)
                {
                    $cell = str_replace($this->enclosure, ($this->enclosure . $this->enclosure), $cell);
                }
    
                if ($countEnclosure || $countDelimiter || $countCR || $countLF)
                {
                    $cell = $this->enclosure . $cell . $this->enclosure;
                }
                
                return $cell;
                
            }, $row));
            
        }, $this->getArrayCopy()));
    }
    
    /**
     * –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –≤ CSV-—Ñ–∞–π–ª
     * @see http://php.net/manual/ru/function.file-put-contents.php
     * 
     * @param string $path
     * @param $flags
     * 
     * @return int|false
     */
    public function saveToFile($path, $flags = LOCK_EX)
    {
        return file_put_contents($path, (string)$this, $flags);
    }
    
    /**
     * –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–∞–≥–æ–ª–æ–≤–∫–∏ –ø–æ–ª–µ–π
     * 
     * @param bool $flag
     * 
     * @return $this
     */
    public function withHeaders($flag = true)
    {
        $this->withHeaders = $flag;
        return $this;
    }
    
    /**
     * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∑–∞–≥–æ–ª–æ–≤–∫–∏ –ø–æ–ª–µ–π
     * 
     * @param array $headers
     * 
     * @return $this
     */
    public function setHeaders(array $headers)
    {
        $this->headers = $headers;
        return $this;
    }
    
    /**
     * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–∞–≥–æ–ª–æ–≤–∫–∏ –ø–æ–ª–µ–π
     * 
     * @return array|false
     */
    public function getHeaders()
    {
        return $this->withHeaders ? $this->headers : false;
    }
    
    /**
     * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –ø–æ–ª–µ–π
     * 
     * @param string $delimiter
     * 
     * @return $this
     */
    public function setDelimiter($delimiter)
    {
        $this->delimiter = $delimiter;
        return $this;
    }
    
    /**
     * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –ø–æ–ª–µ–π
     *
     * @return string
     */
    public function getDelimiter()
    {
        return $this->delimiter;
    }
    
    /**
     * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–∏—Ç–µ–ª—å–Ω—ã–π —Å–∏–º–≤–æ–ª –ø–æ–ª–µ–π
     *
     * @param string $enclosure
     * 
     * @return $this
     */
    public function setEnclosure($enclosure)
    {
        $this->enclosure = $enclosure;
        return $this;
    }
    
    /**
     * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–∏—Ç–µ–ª—å–Ω—ã–π —Å–∏–º–≤–æ–ª –ø–æ–ª–µ–π
     *
     * @return string
     */
    public function getEnclosure()
    {
        return $this->enclosure;
    }
    
    /**
     * @param $encoding
     * 
     * @return $this
     */
    public function setInputEncoding($encoding)
    {
        $this->inputEncoding = $encoding;
        return $this;
    }
    
    /**
     * @return string
     */
    public function getInputEncoding()
    {
        return $this->inputEncoding;
    }
    
    /**
     * @param $encoding
     * 
     * @return $this
     */
    public function setOutputEncoding($encoding)
    {
        if ($encoding !== $this->outputEncoding)
        {
            // encode all rows
            
            if ($this->count())
            {
                //
            }
            
            if (count($this->headers))
            {
                //
            }
        }
        
        $this->outputEncoding = $encoding;
        return $this;
    }
    
    /**
     * @return string
     */
    public function getOutputEncoding()
    {
        return $this->outputEncoding;
    }
    
    /**
     * –î–æ–±–∞–≤–ª—è–µ—Ç mime-—Ç–∏–ø –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ CSV-—Ñ–∞–π–ª–æ–≤
     * 
     * @param string $mimeType
     * 
     * @return $this
     */
    public function addMimeType($mimeType)
    {
        $this->mimeTypes[] = $mimeType;
        return $this;
    }
    
    /**
     * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç mime-—Ç–∏–ø —Ñ–∞–π–ª–∞
     * 
     * @param string $path
     * @throws FileNotFoundException
     * 
     * @return string
     */
    public function getFileMimeType($path)
    {
        if (!is_file($path))
        {
            throw new FileNotFoundException($path);
        }
        
        return self::$finfo->file($path, FILEINFO_MIME_TYPE);
    }
    
    /**
     * –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–∞–∫ —Ñ—É–Ω–∫—Ü–∏—è, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç CSV –≤ –≤–∏–¥–µ –º–∞—Å—Å–∏–≤–∞
     *
     * @return array
     */
    public function __invoke()
    {
        return $this->getArrayCopy();
    }
}